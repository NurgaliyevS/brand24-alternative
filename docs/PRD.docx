PRD: Onboarding Flow - Simplified Implementation
1. Web Scraping Service - Puppeteer with Next.js

Tool Selection

Primary: Puppeteer (handles SPAs, dynamic content, JavaScript rendering)
Fallback: None needed - Puppeteer covers all cases

What to Extract

Page title
Meta description
Meta keywords
H1-H3 headings (first 10)
Body text from paragraphs/content sections (first 2000 chars)
Wait for dynamic content to load

API Endpoint

Route: /api/analyze-website
Method: POST
Input: { website: string }
Output: { success: boolean, data: ScrapedData, error?: string }

Performance Requirements

Timeout: 30 seconds max
Wait Strategy: networkidle2 + 2 second buffer
Resource Limits: Single page, headless mode
Error Handling: Graceful failures with meaningful messages

Validation Requirements

URL format validation
Protocol validation (http/https only)

Deployment Considerations

Development: Standard Puppeteer
Production: Puppeteer-core + Chromium binary for serverless
Memory: Handle browser cleanup properly
Concurrency: One browser instance per request

2. AI/Keyword Analysis Service - GPT-4 Only
typescript// /lib/keyword-analyzer.ts
import OpenAI from 'openai';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

interface ScrapedData {
  title: string;
  description: string;
  headings: string[];
  bodyText: string;
}

export async function generateKeywords(scrapedData: ScrapedData, website: string) {
  const domain = new URL(website).hostname.replace('www.', '');
  
  const prompt = `
    Analyze this company website and suggest exactly 4 keywords for monitoring:
    
    Website: ${website}
    Title: ${scrapedData.title}
    Description: ${scrapedData.description}
    Main headings: ${scrapedData.headings.slice(0, 5).join(', ')}
    Content sample: ${scrapedData.bodyText.substring(0, 500)}
    
    Rules:
    1. Include the company brand name as "Own Brand"
    2. Include 2-3 main competitors as "Competitor" 
    3. Estimate mentions as "low", "medium", or "high"
    4. Assign colors: green for own brand, blue/purple/yellow for competitors
    
    Return ONLY valid JSON in this exact format:
    {
      "companyName": "Company Name",
      "keywords": [
        {
          "name": "brand name",
          "type": "Own Brand",
          "mentions": "low",
          "color": "bg-green-500"
        },
        {
          "name": "competitor1",
          "type": "Competitor", 
          "mentions": "medium",
          "color": "bg-blue-500"
        }
      ]
    }
  `;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [{ role: "user", content: prompt }],
      temperature: 0.3,
      max_tokens: 500,
    });

    const result = JSON.parse(response.choices[0].message.content);
    
    // Add IDs to keywords
    result.keywords = result.keywords.map((keyword: any, index: number) => ({
      ...keyword,
      id: `keyword_${Date.now()}_${index}`
    }));
    
    return result;
  } catch (error) {
    throw new Error(`AI analysis failed: ${error.message}`);
  }
}
API Route:
typescript// /pages/api/keywords/generate.ts
import { generateKeywords } from '@/lib/keyword-analyzer';

export async function POST(request: Request) {
  try {
    const { scrapedData, website } = await request.json();
    
    const analysis = await generateKeywords(scrapedData, website);
    
    return Response.json({
      success: true,
      data: analysis
    });
  } catch (error) {
    return Response.json({
      success: false,
      error: error.message
    }, { status: 500 });
  }
}

3. Database Schemas - MongoDB + Mongoose
Install Dependencies:
bashnpm install mongoose
npm install -D @types/mongoose
Connection:
typescript// /lib/mongodb.ts
import mongoose from 'mongoose';

const MONGODB_URI = process.env.MONGODB_URI!;

if (!MONGODB_URI) {
  throw new Error('Please define the MONGODB_URI environment variable');
}

let cached = global.mongoose;

if (!cached) {
  cached = global.mongoose = { conn: null, promise: null };
}

async function connectDB() {
  if (cached.conn) {
    return cached.conn;
  }

  if (!cached.promise) {
    cached.promise = mongoose.connect(MONGODB_URI).then((mongoose) => {
      return mongoose;
    });
  }

  try {
    cached.conn = await cached.promise;
  } catch (e) {
    cached.promise = null;
    throw e;
  }

  return cached.conn;
}

export default connectDB;
Schemas:
typescript// /models/Company.ts
import mongoose, { Schema, Document } from 'mongoose';

export interface IKeyword {
  id: string;
  name: string;
  type: 'Own Brand' | 'Competitor';
  mentions: 'low' | 'medium' | 'high';
  color: string;
}

export interface ICompany extends Document {
  name: string;
  website: string;
  title?: string;
  description?: string;
  keywords: IKeyword[];
  scrapedData?: {
    headings: string[];
    bodyText: string;
  };
  createdAt: Date;
  updatedAt: Date;
}

const KeywordSchema = new Schema({
  id: { type: String, required: true },
  name: { type: String, required: true },
  type: { type: String, enum: ['Own Brand', 'Competitor'], required: true },
  mentions: { type: String, enum: ['low', 'medium', 'high'], required: true },
  color: { type: String, required: true }
});

const CompanySchema = new Schema({
  name: { type: String, required: true },
  website: { type: String, required: true, unique: true },
  title: { type: String },
  description: { type: String },
  keywords: [KeywordSchema],
  scrapedData: {
    headings: [String],
    bodyText: String
  }
}, {
  timestamps: true
});

export default mongoose.models.Company || mongoose.model<ICompany>('Company', CompanySchema);
Onboarding Session Schema:
typescript// /models/OnboardingSession.ts
import mongoose, { Schema, Document } from 'mongoose';

export interface IOnboardingSession extends Document {
  website: string;
  step: number;
  status: 'in_progress' | 'completed' | 'failed';
  scrapedData?: any;
  analysisData?: any;
  createdAt: Date;
  updatedAt: Date;
}

const OnboardingSessionSchema = new Schema({
  website: { type: String, required: true },
  step: { type: Number, default: 1 },
  status: { type: String, enum: ['in_progress', 'completed', 'failed'], default: 'in_progress' },
  scrapedData: { type: Schema.Types.Mixed },
  analysisData: { type: Schema.Types.Mixed }
}, {
  timestamps: true
});

export default mongoose.models.OnboardingSession || mongoose.model<IOnboardingSession>('OnboardingSession', OnboardingSessionSchema);
Save Complete Onboarding:
typescript// /pages/api/onboarding/complete.ts
import connectDB from '@/lib/mongodb';
import Company from '@/models/Company';

export async function POST(request: Request) {
  try {
    await connectDB();
    
    const { website, keywords, companyName, scrapedData } = await request.json();
    
    const company = new Company({
      name: companyName,
      website,
      title: scrapedData.title,
      description: scrapedData.description,
      keywords,
      scrapedData: {
        headings: scrapedData.headings,
        bodyText: scrapedData.bodyText
      }
    });
    
    await company.save();
    
    return Response.json({
      success: true,
      companyId: company._id
    });
  } catch (error) {
    return Response.json({
      success: false,
      error: error.message
    }, { status: 500 });
  }
}
